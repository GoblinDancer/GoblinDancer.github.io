<script>
const API_GET = 'https://fcc1t9cb2d.execute-api.eu-north-1.amazonaws.com/default/GetTimerValue';
const API_UPDATE = 'https://tgkm2ga3g9.execute-api.eu-north-1.amazonaws.com/default/UpdateTimer';

const countdownElement = document.getElementById('countdown-timer');
const inactiveGoblin = document.getElementById('inactive-goblin');
const activeGoblin = document.getElementById('active-goblin');
const backgroundMusic = document.getElementById('background-music');

let remainingSeconds = 0;
let updateInterval = null;

// Zeit formatieren (HH:MM:SS)
function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    const pad = num => num.toString().padStart(2, '0');
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
}

// Countdown starten
function startCountdown() {
    if (updateInterval) return; // nur einmal starten
    updateInterval = setInterval(() => {
        if (remainingSeconds > 0) {
            remainingSeconds--;
            countdownElement.textContent = formatTime(remainingSeconds);
        } else {
            countdownElement.textContent = "00:00:00";
            inactiveGoblin.style.opacity = 1;
            activeGoblin.style.opacity = 0;
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            clearInterval(updateInterval);
            updateInterval = null;
        }
    }, 1000);
}

// Timer von Lambda abrufen
function updateTimer() {
    fetch(API_GET)
        .then(response => response.json())
        .then(data => {
            const now = Math.floor(Date.now() / 1000);
            const endTimestamp = data.endTimestamp || now;
            const newRemaining = Math.max(0, endTimestamp - now);

            if (newRemaining !== remainingSeconds) {
                remainingSeconds = newRemaining;
                countdownElement.textContent = formatTime(remainingSeconds);
            }

            if (remainingSeconds > 0) {
                inactiveGoblin.style.opacity = 0;
                activeGoblin.style.opacity = 1;
                backgroundMusic.play().catch(() => {}); // Fehler abfangen, falls Autoplay blockiert
            } else {
                inactiveGoblin.style.opacity = 1;
                activeGoblin.style.opacity = 0;
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }

            startCountdown();
        })
        .catch(error => {
            console.error('Fehler beim Abrufen des Timer-Werts:', error);
            countdownElement.textContent = 'Fehler!';
        });
}

// --- Timer initial abrufen ---
updateTimer();
setInterval(updateTimer, 30000); // alle 30 Sekunden neuen Endwert holen
</script>
